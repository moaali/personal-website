webpackJsonp([8,32],{105:function(n,e,t){"use strict";(function(n){function r(n){return n&&n.__esModule?n:{default:n}}Object.defineProperty(e,"__esModule",{value:!0}),e.default=void 0;var o=r(t(2)),a=r(t(221)),s=r(t(57)),p=r(t(775));!function(){var e=t(1).enterModule;e&&e(n)}();var c=function(){return o.default.createElement(s.default,null,o.default.createElement("div",{id:"post"},o.default.createElement("hgroup",{className:"mB-60"},o.default.createElement("h5",{className:"c-minor"},"Sep 17, 2017"),o.default.createElement("h1",{className:"c-blocker"},"ES6 Overview - Proxy"),o.default.createElement("hr",null)),o.default.createElement(a.default,{source:p.default})))},i=c,l=i;e.default=l,function(){var e=t(1).default,r=t(1).leaveModule;e&&(e.register(c,"Es6OverviewProxy","E:\\Dropbox\\Projects\\personal-website\\src\\screens\\Blog\\components\\Es6OverviewProxy\\index.jsx"),e.register(i,"default","E:\\Dropbox\\Projects\\personal-website\\src\\screens\\Blog\\components\\Es6OverviewProxy\\index.jsx"),r(n))}()}).call(e,t(7)(n))},775:function(n,e){n.exports="### Proxy\n\n#### Description\nObject used to override/customize default behavior of fundamental operations on other objects.\n\n\n#### Syntax\n```javascript\n/**\n * Proxy Object.\n * @param  {*}      target  target object to operate on\n * @param  {Object} handler tarps container\n * @return {Proxy}          Proxy Object\n */\nconst p = new Proxy(target, handler)\n```\n\n\n#### Practical Usage\nHere are some of the practical usages of the `Proxy` object. (VIEW REPO OF THE FOLLOWING EXAMPLES HERE).\n\n1. Listening to changes on a specific object.\n2. Object members type validation.\n3. Achieving true private members.\n4. Revoking access to data.\n5. Intercepting certain operations on objects.\n\n\n#### API\n\n1. **`Proxy.revocable()`**\n2. **`handler.getPrototypeOf()`**\n3. **`handler.setPrototypeOf()`**\n4. **`handler.isExtensible()`**\n5. **`handler.preventExtensions()`**\n6. **`handler.getOwnPropertyDescriptor()`**\n7. **`handler.defineProperty()`**\n8. **`handler.has()`**\n9. **`handler.get()`**\n10. **`handler.set()`**\n11. **`handler.deleteProperty()`**\n12. **`handler.ownKeys()`**\n13. **`handler.apply()`**\n14. **`handler.construct()`**\n\n\n##### **`Proxy.revocable()`**\n\n###### Description\nCreates a revocable `Proxy` object.\n\n\n###### Syntax\n```javascript\n /**\n * Creates a revocable Proxy object.\n * @param  {*}      target  target object to operate on\n * @param  {Object} handler tarps container\n *\n * @return {Object}\n *    Object with two props `proxy` containing the Proxy Object\n *    and `revoke` method to terminate the proxy.\n */\nProxy.revocable(target, handler);\n```\n\n\n\n###### Examples\n```javascript\nlet\n  revocable = Proxy.revocable({}, {\n    get(target, name) {\n      return `GET: \"${name}\" Property`\n    }\n  });\n\nlet p = revocable.proxy;\n\nconsole.log(p.a); // => GET: \"a\" Property\n\n// when calling this method every trap throws a TypeError\nrevocable.revoke();\n\nconsole.log(p.a); // => TypeError\n\n```\n\n\n\n\n##### **`handler.getPrototypeOf()`**\n\n###### Description\nIntercepts/Customizes `[[GetPrototypeOf]]` operations.\n.\n\n\n###### Syntax\n```javascript\n/**\n * Intercept [[GetPrototypeOf]] Operations.\n *\n * @param  {Object} target => target object to find prototype for.\n *\n * @return {Object|null}\n *\n * @exceptions\n *   + TypeError\n *     01. Returned value isn't `null` || `Object`.\n *     02. Target object isn't extensible.\n */\nhandler.getPrototypeOf(target);\n```\n\n\n\n###### Examples\n```javascript\nlet\n  obj   = {},\n  proto = {},\n  getProto;\n\ngetProtoProxy = target => {\n  const handler = {\n    getPrototypeOf(target) {\n      console.log('[[GetProtoType]] Trapped')\n      return proto;\n    }\n  }\n\n  return new Proxy(target, handler);\n}\n\nlet p = getProtoProxy(obj);\nconsole.log(Object.getPrototypeOf(p)) // => [[GetProtoType]] Trapped {}\n```\n\n\n\n###### Notes\n- `handler.getPrototypeOf()` traps any operation that depends on `[[GetProtoType]]` internal method which will be one of the following:\n  1. `Object.getPrototypeOf()`\n  2. `Reflect.getPrototypeOf()`\n  3. `Object.prototype.isPrototypeOf`\n  4. `instanceof`\n  5. `__proto__`\n\n\n\n\n\n##### **`handler.setPrototypeOf()`**\n\n###### Description\nIntercepts/Customizes `Object.setPrototypeOf()` operations.\n\n\n###### Syntax\n```javascript\n/**\n * Intercept setting `[[Prototype]]` internal property Operations.\n *\n * @param  {Object} target    => target object to set prototype for.\n * @param  {Object} prototype => object to set as prototype for target.\n *\n * @return {Boolean}\n *    true if the prototype is set, false otherwise.\n *\n * @exceptions\n *   + TypeError\n *     01. Target object isn't extensible. So the prototype object should be\n *         the same as `Object.getPrototypeOf()`\n */\nhandler.setPrototypeOf(target, prototype);\n```\n\n\n\n###### Examples\n```javascript\nlet\n  obj   = {},\n  proto = {},\n  setProtoProxy;\n\nsetProtoProxy = (target, proto) => {\n  const handler = {\n    setPrototypeOf(target, proto) {\n      return true\n    }\n  };\n\n  return new Proxy(target, proto);\n};\n\nconst p = setProtoProxy(obj, proto);\nconsole.log(Object.setPrototypeOf(p, null)) // => { a: 1 }\n```\n\n\n###### Notes\n- `handler.setPrototypeOf()` traps any operation that depends on setting `[[ProtoType]]` internal property which will be one of the following:\n  1. `Object.setPrototypeOf()`\n  2. `Reflect.setPrototypeOf()`\n\n\n##### **`handler.isExtensible()`**\n\n###### Description\nIntercepts/Customizes `Object.isExtensible()` operations.\n\n\n###### Syntax\n```javascript\n/**\n * Intercept `Object.isExtensible()` Operations.\n *\n * @param  {Object} target => target object to check its extensibility.\n *\n * @return {Boolean}\n *    true if the object is extensible, false otherwise.\n *\n * @exceptions\n *   + TypeError\n *     01. `Object.isExtensible(proxy)` !== `Object.isExtensible(obj)`\n */\nhandler.isExtensible(target);\n```\n\n\n\n###### Examples\n```javascript\nlet\n  obj      = {},\n  nonExObj = {},\n  extendProxy;\n\nObject.preventExtensions(nonExObj);\n\nextendProxy = target => {\n  const handler = {\n    isExtensible(target) {\n      console.log('isExtensible is accessed!!');\n      return Reflect.isExtensible(target);\n    }\n  }\n\n  return new Proxy(target, handler)\n}\n\nlet\n  p1 = extendProxy(obj),\n  p2 = extendProxy(nonExObj);\n\nconsole.log(Object.isExtensible(p1)); // => isExtensible is accessed!, true\nconsole.log(Object.isExtensible(p2)); // => isExtensible is accessed!, false\n```\n\n\n\n##### **`handler.preventExtensions()`**\n\n###### Description\nIntercepts/Customizes `Object.preventExtensions()` operation.\n\n\n###### Syntax\n```javascript\n/**\n * Intercept `Object.preventExtensions()` Operation.\n *\n * @param  {Object} target => target object to prevent extensibility for.\n *\n * @return {Boolean}\n *    true if the object is extensible, false otherwise.\n *\n * @exceptions\n *   + TypeError\n *     01. `Object.preventExtensions(proxy)` === Object.isExtensible(proxy)\n */\nhandler.preventExtensions(target);\n```\n\n\n\n###### Examples\n\n```javascript\nlet\n  obj      = {},\n  extendProxy;\n\nextendProxy = target => {\n  const handler = {\n    preventExtensions(target) {\n      console.log('preventExtensions is accessed!!');\n      return Reflect.preventExtensions(target)\n    }\n  }\n\n  return new Proxy(target, handler)\n}\n\nlet p = extendProxy(obj);\n\nconsole.log(Object.preventExtensions(p)); // => isExtensible is accessed!, true\n```\n\n\n\n\n##### **`handler.getOwnPropertyDescriptor()`**\n\n###### Description\nIntercepts/Customizes `Object.getOwnPropertyDescriptor()` operation.\n\n\n###### Syntax\n```javascript\n/**\n * Intercept `Object.getOwnPropertyDescriptor()` Operation.\n *\n * @param  {Object} target   => target object to look for property in.\n * @param  {String} property => property to get descriptor for.\n *\n * @return {Object|undefined}\n *    descriptor object for the property or undefined if it doesn't exist.\n *\n * @exceptions\n *   + TypeError\n *     01. Return isn't `Object` or `undefined`.\n *     02. Return undefined for existed property in non-extensible target\n *     03. Return undefined for non-configurable property in target\n */\nhandler.getOwnPropertyDescriptor(target, property);\n```\n\n\n\n###### Examples\n```javascript\nlet\n  obj  = {a: 1},\n  obj2 = {c: 2},\n  describeProxy;\n\nObject.preventExtensions(obj2);\nObject.defineProperty(obj, 'b', {configurable: false});\n\ndescribeProxy = (target, prop) => {\n  const handler = {\n    getOwnPropertyDescriptor(target, prop) {\n      console.log('getOwnPropertyDescriptor is accessed!!');\n      return undefined;\n    }\n  }\n\n  return new Proxy(target, handler)\n}\n\nlet\n  p1 = describeProxy(obj, 'a'),\n  p2 = describeProxy(obj, 'b'),\n  p3 = describeProxy(obj2, 'c');\n\nconsole.log(Object.getOwnPropertyDescriptor(p1, 'a')) // => Descriptor Object\nconsole.log(Object.getOwnPropertyDescriptor(p2, 'b')) // => TypeError: non-configurable property\nconsole.log(Object.getOwnPropertyDescriptor(p3, 'c')) // => TypeError: non-extensible object\n```\n\n\n\n\n##### **`handler.defineProperty()`**\n\n###### Description\nIntercepts/Customizes `Object.defineProperty()` operation.\n\n\n###### Syntax\n```javascript\n/**\n * Intercept `Object.defineProperty()` Operation.\n *\n * @param  {Object} target     => target object to look for property in.\n * @param  {String} property   => property to define on target object.\n * @param  {Object} descriptor => descriptor object for the specified property.\n *\n * @return {Boolean}\n *    true if the property is set, false otherwise.\n *\n * @exceptions\n *   + TypeError\n *     01. Return false in `strict mode`.\n *     02. Setting configurable existed property to be non-configurable.\n *     03. Adding/modifying non-configurable property that doesn't exist as\n *         non-configurable.\n */\nhandler.defineProperty(target, property, descriptor);\n```\n\n\n\n###### Examples\n```javascript\nlet\n  obj  = {a: 1},\n  defineProxy;\n\nObject.defineProperty(obj, 'b', {configurable: false});\n\ndefineProxy = (target) => {\n  const handler = {\n    defineProperty(target, prop, descriptor) {\n      console.log('defineProperty is accessed!!');\n      return true;\n    }\n  }\n\n  return new Proxy(target, handler)\n}\n\nlet p = defineProxy(obj);\n\nconsole.log(Object.defineProperty(p, 'a', {configurable: false})) // => TypeError\nconsole.log(Object.defineProperty(p, 'd', {configurable: false})) // => TypeError\nconsole.log(Object.defineProperty(p, 'b', {writable: false})) // => Object\n```\n\n\n\n\n##### **`handler.has()`**\n\n###### Description\nIntercepts/Customizes `in` operator lookups.\n\n\n###### Syntax\n```javascript\n/**\n * Intercepts/Customizes `in` operator lookups.\n *\n * @param  {Object} target     => target object to look for property in.\n * @param  {String} property   => property to look for in target object.\n *\n * @return {Boolean}\n *    true if the property exists, false otherwise.\n *\n * @exceptions\n *   + TypeError\n *     01. Return false if the property exists.\n */\nhandler.has(target, property);\n```\n\n\n\n###### Examples\n```javascript\nlet\n  obj  = {a: 1},\n  hasProxy;\n\nObject.defineProperty(obj, 'b', {configurable: false});\n\nhasProxy = (target) => {\n  const handler = {\n    has(target, prop) {\n      console.log('has is accessed!!');\n      return true;\n    }\n  }\n\n  return new Proxy(target, handler)\n}\n\nlet p = hasProxy(obj);\n\nconsole.log('a' in p) // => has is accessed!!, true\n```\n\n\n\n\n##### **`handler.get()`**\n\n###### Description\nIntercepts/Customizes a property value.\n\n\n###### Syntax\n```javascript\n/**\n * Intercepts/Customizes a property value.\n *\n * @param  {Object} target   => target object to look for property in.\n * @param  {String} property => property to look for in target object.\n * @param  {Object} receiver => proxy object.\n *\n * @return {*}\n *    Any value.\n *\n * @exceptions\n *   + TypeError\n *     01. Return different value for non-writable,\n *         non-configurable properties.\n *     02. Not returning `undefined` if the lookup property has value\n *         of `undefined` and non-configurable.\n */\nhandler.get(target, property, receiver);\n```\n\n\n\n###### Examples\n```javascript\nlet\n  obj  = {a: 1},\n  getProxy;\n\nObject.defineProperty(obj, 'b', {configurable: false, writable:false, value: 2});\nObject.defineProperty(obj, 'c', {configurable: false});\n\ngetProxy = (target) => {\n  const handler = {\n    get(target, prop, proxy) {\n      console.log('get is accessed!!');\n      return 1;\n    }\n  }\n\n  return new Proxy(target, handler)\n}\n\nlet p = getProxy(obj);\n\nconsole.log(p.a) // => get is accessed!!, 1\nconsole.log(p.b) // => TypeError\nconsole.log(p.c) // => TypeError\n```\n\n\n\n\n\n##### **`handler.set()`**\n\n###### Description\nIntercepts/Customizes setting a property.\n\n\n###### Syntax\n```javascript\n/**\n * Intercepts/Customizes setting a property.\n *\n * @param  {Object} target   => target object to look set property on.\n * @param  {String} property => property name.\n * @param  {*}      value    => any value.\n * @param  {Object} receiver => proxy object.\n *\n * @return {Boolean}\n *    True if the assignment process is completed\n *    successfully, false otherwise.\n *\n * @exceptions\n *   + TypeError\n *     01. Setting non-writable, non-configurable properties.\n *     02. Setting non-configurable property that has value of `undefined`.\n *     03. Return false from `set` in `strict mode`.\n */\nhandler.set(target, property, value, receiver);\n```\n\n\n\n###### Examples\n```javascript\nlet\n  obj  = {a: 1},\n  setProxy;\n\nObject.defineProperty(obj, 'b', {configurable: false});\nObject.defineProperty(obj, 'c', {configurable: false, writable: false, value: 2});\n\nsetProxy = (target) => {\n  const handler = {\n    set(target, prop, value, proxy) {\n      console.log('set is accessed!!');\n      return true;\n    }\n  }\n\n  return new Proxy(target, handler)\n}\n\nlet p = setProxy(obj);\n\np.a = 1; // => set is accessed!!, 1\np.b = 1; // => TypeError\n```\n\n\n\n##### **`handler.deleteProperty()`**\n\n###### Description\nIntercepts/Customizes `delete` operator.\n\n\n###### Syntax\n```javascript\n/**\n * Intercepts/Customizes `delete` operator.\n *\n * @param  {Object} target   => target object to look set property on.\n * @param  {String} property => property name.\n *\n * @return {Boolean}\n *    True if the delete process is completed\n *    successfully, false otherwise.\n *\n * @exceptions\n *   + TypeError\n *     01. Deleting non-configurable own properties.\n */\nhandler.deleteProperty(target, property);\n```\n\n\n\n###### Examples\n```javascript\nlet\n  obj  = {a: 1},\n  delProxy;\n\nObject.defineProperty(obj, 'b', {configurable: false});\n\ndelProxy = (target) => {\n  const handler = {\n    deleteProperty(target, property) {\n      if (property in target) {\n        console.log(`Property ${property} successfully deleted!!!`);\n        return true\n      } else {\n        console.log(`Property ${property} not found on ${target} object`);\n        return false\n      }\n    }\n  }\n\n  return new Proxy(target, handler)\n}\n\nlet p = delProxy(obj);\n\ndelete p.a; // => Property a successfully deleted!!!, true\ndelete p.b; // => TypeError\n```\n\n\n\n\n##### **`handler.ownKeys()`**\n\n###### Description\nIntercepts/Customizes `Reflect.ownKeys` operation.\n\n\n###### Syntax\n```javascript\n/**\n * Intercepts/Customizes `Reflect.ownKeys` operation.\n *\n * @param  {Object} target => target object to look for its own keys.\n *\n * @return {Boolean}\n *    Array of own enumerable keys.\n *\n * @exceptions\n *   + TypeError\n *     01. Return isn't an array.\n *     02. Returned array containing values types other than\n *         `String` & `Symbol`.\n *     03. Returned array containing non-configurable own properties.\n *     04. Returned array containing non-existence keys of\n *         non-extensible object.\n */\nhandler.ownKeys(target);\n```\n\n\n\n###### Examples\n```javascript\nlet\n  obj  = {a: 1},\n  ownProxy;\n\nObject.defineProperty(obj, 'b', {configurable: false});\n\nownProxy = (target) => {\n  const handler = {\n    ownKeys(target) {\n      console.log(`ownKeys is accessed!!`);\n      return ['a', 'b', 'c']\n    }\n  }\n\n  return new Proxy(target, handler)\n}\n\nlet p = ownProxy(obj);\n\nconsole.log(Object.getOwnPropertyNames(obj)); // => ownKeys is accessed!!, ['a', 'b', 'c']\n```\n\n\n\n###### Notes\n- `handler.ownKeys` intercepts the following operations:\n  1. `Object.keys()`\n  2. `Object.getOwnPopertyNames()`\n  3. `Object.getOwnPropertySymbols()`\n  4. `Reflect.ownKeys()`\n\n\n\n\n##### **`handler.apply()`**\n\n###### Description\nIntercepts/Customizes function calls.\n\n\n###### Syntax\n```javascript\n/**\n * Intercepts/Customizes function calls.\n *\n * @param  {Object} target => target function to intercept its invocation.\n *\n * @return {*}\n *    Any value.\n */\nhandler.apply(target);\n```\n\n\n\n###### Examples\n```javascript\nlet\n  fn  = function () { console.log(\"I'm not gonna show!!\") },\n  applyProxy;\n\napplyProxy = (target) => {\n  const handler = {\n    apply(target, thisArg, argsList) {\n      console.log(`Function is called`);\n    }\n  }\n\n  return new Proxy(target, handler)\n}\n\nlet p = applyProxy(fn);\n\nconsole.log(p()); // => Function is called\n```\n\n\n\n\n\n##### **`handler.construct()`**\n\n###### Description\nIntercepts/Customizes `new` operator.\n\n\n###### Syntax\n```javascript\n/**\n Intercepts/Customizes `new` operator.\n *\n * @param  {Function} target   => constructor function/class.\n * @param  {Array}    argsList => array of the passed arguments to constructor.\n * @param  {Object}   proxy    => called proxy constructor.\n *\n * @return {Object}\n *\n * @exceptions\n *   + TypeError\n *     01. Return isn't Object.\n *     02. Target isn't a valid constructor.\n */\nhandler.construct(target, argsList, proxy);\n```\n\n\n\n###### Examples\n```javascript\nlet\n  C  = function () {},\n  constructProxy;\n\nconstructProxy = (target) => {\n  const handler = {\n    construct(target, argsList, proxy) {\n      console.log(`Construct is accessed`);\n      return {}\n    }\n  }\n\n  return new Proxy(target, handler)\n}\n\nlet p = constructProxy(C);\n\nconsole.log(new p()); // => Construct is accessed, Object {}\n```\n"}});