webpackJsonp([2,26],{111:function(r,n,e){"use strict";(function(r){function t(r){return r&&r.__esModule?r:{default:r}}Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var o=t(e(2)),s=t(e(221)),a=t(e(57)),l=t(e(781));!function(){var n=e(1).enterModule;n&&n(r)}();var i=function(){return o.default.createElement(a.default,null,o.default.createElement("div",{id:"post"},o.default.createElement("hgroup",{className:"mB-60"},o.default.createElement("h5",{className:"c-minor"},"Sep 10, 2017"),o.default.createElement("h1",{className:"c-blocker"},"ES6 Overview - Symbols"),o.default.createElement("hr",null)),o.default.createElement(s.default,{source:l.default})))},c=i,p=c;n.default=p,function(){var n=e(1).default,t=e(1).leaveModule;n&&(n.register(i,"Es6OverviewSymbols","E:\\personal-website\\src\\screens\\Blog\\components\\Es6OverviewSymbols\\index.jsx"),n.register(c,"default","E:\\personal-website\\src\\screens\\Blog\\components\\Es6OverviewSymbols\\index.jsx"),t(r))}()}).call(n,e(7)(r))},781:function(r,n){r.exports="### Symbols\r\n\r\n#### Description\r\nFunction that returns unique identifier of `symbol` primitive type for each call.\r\n\r\n\r\n#### Syntax\r\n```javascript\r\nSymbol('optional string value')\r\n```\r\n\r\n\r\n#### Usage\r\n- One of the usual practical usages of `Symbol()` function is generate unique identifiers for object properties.\r\n\r\n\r\n\r\n#### Examples\r\n```javascript\r\nconst obj = {\r\n  [Symbol()]    : 1,\r\n  [Symbol('y')] : 2,\r\n  [Symbol('z')] : 3,\r\n  [Symbol('z')] : 4\r\n}\r\n\r\nconst\r\n  syms  = Object.getOwnPropertySymbols(obj),\r\n  symZ1 = obj[syms[2]],\r\n  symZ2 = obj[syms[3]];\r\n\r\nconsole.log(syms)    // => [Symbol(), Symbol(y), Symbol(z), Symbol(z)]\r\nconsole.log(syms[2]) // => Symbol(z)\r\nconsole.log(syms[3]) // => Symbol(z)\r\nconsole.log(symZ1)   // => 3\r\nconsole.log(symZ2)   // => 4\r\n```\r\n\r\n\r\n\r\n\r\n#### API\r\n\r\n1. **`Symbol.iterator`**\r\n2. **`Symbol.match`**\r\n3. **`Symbol.replace`**\r\n4. **`Symbol.search`**\r\n5. **`Symbol.split`**\r\n6. **`Symbol.hasInstance`**\r\n7. **`Symbol.isConcatSpreadable`**\r\n8. **`Symbol.unscopables`**\r\n9. **`Symbol.species`**\r\n10. **`Symbol.toPrimitive`**\r\n11. **`Symbol.toStringTag`**\r\n12. **`Symbol.for(key)`**\r\n13. **`Symbol.keyFor(sym)`**\r\n\r\n\r\n##### **`Symbol.iterator`**\r\n\r\n###### Description\r\nMethod used to define iteration behavior of its owner object.\r\n\r\n\r\n\r\n###### Syntax\r\n```javascript\r\nconst obj = {\r\n  *[Symbol.iterator]() {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n###### Examples\r\n```javascript\r\nconst evenIt = {\r\n  *[Symbol.iterator]() {\r\n    for (let i = 0;; i += 2)\r\n      yield i\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Prints even numbers from start to end numbers.\r\n *\r\n * @param  {Number} x starting number.\r\n * @param  {Number} y end number.\r\n * @return {void}\r\n */\r\n\r\nconst print = (x, y) => {\r\n  for (let val of evenIt) {\r\n    if (val >= x && val <= y)\r\n      console.log(val);\r\n\r\n    if (val === y)\r\n      break;\r\n  }\r\n}\r\n\r\nprint(2, 20)\r\n```\r\n\r\n\r\n\r\n###### Notes\r\n- Exists as a build-in method on `Array`, `TypedArray`, `Map`, `Set`.\r\n\r\n\r\n##### **`Symbol.match`**\r\n\r\n###### Description\r\nMethod used to define if a RegExp object should be treated as a regular expression or just a normal string\r\n\r\n\r\n###### Syntax\r\n```javascript\r\nregexp[Symbol.match](str)\r\n```\r\n\r\n\r\n\r\n###### Examples\r\n```javascript\r\nconst re = /a/\r\n'/a/'.startsWith(re) // => TypeError -> Because startsWith() expects re to be a string not RegExp.\r\n\r\n// Now when modifying the behavior of `re` as string there will be no errors.\r\nre[Symbol.match] = false\r\n'/a/'.startsWith(re) // => true\r\n```\r\n\r\n\r\n\r\n##### **`Symbol.replace`**\r\n\r\n###### Description\r\nMethod used to define how `String.prototype.replace()` should work.\r\n\r\n\r\n###### Syntax\r\n```javascript\r\nregexp[Symbol.replace](str, newSubStr) // => true\r\n```\r\n\r\n\r\n\r\n###### Usage\r\n- This method has usually one practical usage which is defining how `String.prototype.replace()` will work when using subclasses of `RegExp` to form its regular expression patterns.\r\n\r\n\r\n\r\n###### Examples\r\n```javascript\r\nclass MyRegExp extends RegExp {\r\n  constructor(ptrn, flags) {\r\n    super(ptrn, flags);\r\n  }\r\n\r\n  [Symbol.replace](input, replacement) {\r\n    return RegExp.prototype[Symbol.replace].call(this, input, (replacement + ' REPLACEMENT')) // => Every replacement will contain 'REPLACEMENT' now\r\n  }\r\n}\r\n\r\n\r\nconst\r\n  re     = new MyRegExp(/My/, 'i'),\r\n  str    = 'My ',\r\n  newstr = str.replace(re, 'Your');\r\n\r\nconsole.log(newstr); // => 'Your REPLACEMENT'\r\n```\r\n\r\n\r\n\r\n##### **`Symbol.search`**\r\n\r\n###### Description\r\nMethod used to define how `String.prototype.search()` should work.\r\n\r\n\r\n###### Syntax\r\n```javascript\r\nregexp[Symbol.search](str)\r\n```\r\n\r\n\r\n\r\n###### Usage\r\n- This method has usually one practical usage which is defining how `String.prototype.search()` will work when using subclasses of `RegExp` to form its regular expression patterns.\r\n\r\n\r\n\r\n###### Examples\r\n```javascript\r\nclass MyRegExp extends RegExp {\r\n  constructor(ptrn, flags) {\r\n    super(ptrn, flags);\r\n    this.ptrn = ptrn\r\n  }\r\n\r\n  [Symbol.search](str) {\r\n    return `Found At : ${str.indexOf(this.ptrn)}`\r\n  }\r\n}\r\n\r\n\r\nconst\r\n  re  = new MyRegExp('My'),\r\n  str = 'My',\r\n  pos = str.search(re);\r\n\r\nconsole.log(pos); // => Found At : 0\r\n```\r\n\r\n\r\n\r\n##### **`Symbol.split`**\r\n\r\n###### Description\r\nMethod used to define how `String.prototype.split()` should work.\r\n\r\n\r\n###### Syntax\r\n```javascript\r\nregexp[Symbol.split](str[, limit])\r\n```\r\n\r\n\r\n\r\n###### Usage\r\n- This method has usually one practical usage which is defining how `String.prototype.split()` will work when using subclasses of `RegExp` to form its regular expression patterns.\r\n\r\n\r\n\r\n###### Examples\r\n```javascript\r\nclass MyRegExp extends RegExp {\r\n  [Symbol.split](str, limit) {\r\n    let result = RegExp.prototype[Symbol.split].call(this, str, limit)\r\n    return result.reduce((acc, elem) => acc + elem)\r\n  }\r\n}\r\n\r\n\r\nconst\r\n  re  = new MyRegExp('-'),\r\n  str = 'a-b-c-d',\r\n  res = str.split(re);\r\n\r\nconsole.log(res); // => abcd\r\n```\r\n\r\n\r\n\r\n##### **`Symbol.hasInstance`**\r\n\r\n###### Description\r\nMethod used to customize the behavior of `instanceof` operator.\r\n\r\n\r\n###### Syntax\r\n```javascript\r\n[Symbol.hasInstance](instance)\r\n```\r\n\r\n\r\n\r\n###### Usage\r\n- This method has usually one practical usage which is defining how `instanceof` operator will work when defining classes and what objects should be instances of it.\r\n\r\n\r\n\r\n###### Examples\r\n```javascript\r\nclass MyObject {\r\n  static [Symbol.hasInstance](ins) {\r\n    return ins.toString() === '[object Object]'\r\n  }\r\n}\r\n\r\nconsole.log({} instanceof MyObject); // => true\r\n```\r\n\r\n\r\n\r\n##### **`Symbol.isConcatSpreadable`**\r\n\r\n###### Description\r\nProperty with boolean value used to define if the target object (array / array-like) should be spreaded/flattened when used with methods like `Array.prototype.concat()`.\r\n\r\n\r\n###### Syntax\r\n```javascript\r\nobj[Symbol.isConcatSpreadable] = true/false\r\n```\r\n\r\n\r\n\r\n###### Examples\r\n```javascript\r\nconst\r\n  arr = [1, 2, 3],\r\n  arrLike = {\r\n    length: 2,\r\n    0: 'a',\r\n    1: 'b'\r\n  };\r\n\r\narr[Symbol.isConcatSpreadable] = false;\r\narrLike[Symbol.isConcatSpreadable] = true;\r\n\r\nconst x = arr.concat(arrLike)\r\nconst y = x.concat(arr)\r\n\r\nconsole.log(x) // => [[1, 2, 3], 'a', 'b']\r\nconsole.log(y) // => [[1, 2, 3], 'a', 'b', [1, 2, 3]]\r\n```\r\n\r\n\r\n\r\n##### **`Symbol.unscopables`**\r\n\r\n###### Description\r\nProperty with object value used to define which own/inherited object properties should be available inside `with` statsment.\r\n\r\n\r\n###### Syntax\r\n```javascript\r\nobj[Symbol.unscopables] = { propName: Boolean, ... }\r\n```\r\n\r\n\r\n\r\n###### Examples\r\n```javascript\r\nconst\r\n  obj = {\r\n    a: 0,\r\n    b: 1\r\n  };\r\n\r\nobj[Symbol.unscopables] = {\r\n  a: false,\r\n  b: true\r\n}\r\n\r\nwith (obj) {\r\n  console.log(a) // => 0\r\n  console.log(b) // ReferenceError\r\n}\r\n```\r\n\r\n\r\n\r\n##### **`Symbol.species`**\r\n\r\n###### Description\r\nFunction valued property used to define the constructor of the derived objects from their original objects.\r\n\r\n\r\n###### Syntax\r\n```javascript\r\n[Symbol.species] () { /* code... */ }\r\n```\r\n\r\n\r\n###### Usage\r\n- One of the possible usages of `Symbol.species` is make a copy of the built-in objects in JavaScript like `Object`, `Array`, `Promise` ...etc, and add on them your custom implementations without having to polluting the original built-in objects.\r\n\r\n\r\n\r\n###### Examples\r\n```javascript\r\nclass MyArray extends Array {\r\n  static get [Symbol.species]() {\r\n    return Array\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.length === 0\r\n  }\r\n}\r\n\r\nclass MyArray2 extends Array {\r\n  isEmpty() {\r\n    return this.length === 0\r\n  }\r\n}\r\n\r\nlet arr     = new MyArray(1,2,3);   // Original objects\r\nlet arr2    = new MyArray2(1,2,3);  // Original objects\r\nlet mapped  = arr.map(e => e * 2);  // Derived objects\r\nlet mapped2 = arr2.map(e => e * 2); // Derived objects\r\n\r\nconsole.log( mapped instanceof MyArray )   // => false\r\nconsole.log( mapped instanceof Array )     // => true\r\nconsole.log( mapped2 instanceof MyArray2 ) // => true\r\nconsole.log( mapped2 instanceof Array )    // => true\r\n```\r\n\r\n\r\n\r\n##### **`Symbol.toPrimitive`**\r\n\r\n###### Description\r\nFunction valued property used to define how JavaScript type coercion should work. it takes one argument which is `hint` that can be one of three values `string`, `number`, `default`.\r\n\r\n\r\n###### Syntax\r\n```javascript\r\n[Symbol.toPrimitive] (hint) { /* code... */ }\r\n```\r\n\r\n\r\n\r\n###### Examples\r\n```javascript\r\nlet obj = {}\r\nconsole.log(+obj)     // => NaN\r\nconsole.log(`${obj}`) // => \"[oject Object]\"\r\nconsole.log(obj + '') // => \"[oject Object]\"\r\n\r\nobj[Symbol.toPrimitive] = hint => {\r\n  switch(hint) {\r\n    case 'number':\r\n      return 1;\r\n      break;\r\n    case 'string':\r\n      return 'obj';\r\n      break;\r\n    case 'default':\r\n      return true;\r\n      break;\r\n  }\r\n}\r\n\r\nconsole.log(+obj)     // => 1\r\nconsole.log(`${obj}`) // => \"obj\"\r\nconsole.log('' + obj) // => \"true\"\r\n```\r\n\r\n\r\n\r\n##### **`Symbol.toStringTag`**\r\n\r\n###### Description\r\nFunction valued property used to define a string description of an object. it's used to customize how the `Object.prototype.toString()` method return value.\r\n\r\n\r\n###### Syntax\r\n```javascript\r\n[Symbol.toStringTag] () { return ... }\r\n```\r\n\r\n\r\n\r\n###### Examples\r\n```javascript\r\nclass MyClass1 {}\r\nclass MyClass2 {\r\n  get [Symbol.toStringTag] () {\r\n    return 'MyClass2'\r\n  }\r\n}\r\nconst x = new MyClass1();\r\nconst y = new MyClass2();\r\n\r\nx.toString() // => \"[object Object]\"\r\ny.toString() // => \"[object MyClass2]\"\r\n                         // ^-------- Tag is now pointing to the return of `@@toStringTag`\r\n```\r\n\r\n\r\n\r\n##### **`Symbol.for`**\r\n\r\n###### Description\r\nChecks for the existence of a specified `Symbol` in the global symbols registry and return that `Symbol` if it's found or creates it then return it if not found.\r\n\r\n\r\n###### Syntax\r\n```javascript\r\nSymbol.for(string) \r\n```\r\n\r\n\r\n\r\n###### Examples\r\n```javascript\r\nSymbol.for('x') === Symbol.for('x') // => true -> Symbol(x)\r\nSymbol('x') === Symbol('x') // => false\r\n```\r\n\r\n\r\n\r\n##### **`Symbol.keyFor`**\r\n\r\n###### Description\r\nRetrieves the key used to create the global registry symbol if found otherwise `undefined`.\r\n\r\n\r\n###### Syntax\r\n```javascript\r\nSymbol.keyFor(Symbol)\r\n```\r\n\r\n\r\n###### Examples\r\n```javascript\r\nconst\r\n  sym = Symbol.for('x'),\r\n  locSym = Symbol('y'),\r\n  it = Symbol.iterator;\r\n\r\nconsole.log(Symbol.keyFor(sym));    // => X         - found in the global registry\r\nconsole.log(Symbol.keyFor(locSym)); // => undefined - local symbol not found on the global registry\r\nconsole.log(Symbol.keyFor(it));     // => undefined - well-known symbol not found on the global registry\r\n```\r\n"}});